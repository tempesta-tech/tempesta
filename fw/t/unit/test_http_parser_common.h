/**
 *		Tempesta FW
 *
 * Copyright (C) 2014 NatSys Lab. (info@natsys-lab.com).
 * Copyright (C) 2015-2025 Tempesta Technologies, Inc.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59
 * Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
#ifndef __TFW_HTTP_PARSER_COMMON_H__
#define __TFW_HTTP_PARSER_COMMON_H__

/*
 * Need to define DEBUG before first the inclusions of
 * lib/log.h and linux/printk.h.
 */
#if DBG_HTTP_PARSER > 0
#undef DEBUG
#define DEBUG DBG_HTTP_PARSER
#endif

#include <linux/types.h>
#include <asm/fpu/api.h>
#include <linux/vmalloc.h>

#include "test.h"
#include "helpers.h"
#include "fuzzer.h"

#ifdef EXPORT_SYMBOL
#undef EXPORT_SYMBOL
#endif
#define EXPORT_SYMBOL(...)

#include "msg.h"
#include "str.h"
#include "http_msg.h"
#include "http_parser.h"
#include "http_sess.h"

typedef struct {
	char *buf;
} TfwTestChunk;

enum {
	CHUNK_OFF,
	CHUNK_ON
};

#define TOKEN_ALPHABET_LC	"!#$%&'*+-.0123456789^_`" \
				"abcdefghijklmnopqrstuvwxyz|~"
#define TOKEN_ALPHABET		TOKEN_ALPHABET_LC "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
#define QETOKEN_ALPHABET	TOKEN_ALPHABET "\"="
#define OTHER_DELIMETERS	"(),/:;<=>?@[\\]{}"
#define OBS_TEXT		"\x80\x90\xC8\xAE\xFE\xFF"
#define ETAG_ALPHABET		OTHER_DELIMETERS TOKEN_ALPHABET OBS_TEXT
#define VCHAR_ALPHABET		"\x09 \"" OTHER_DELIMETERS 		\
				TOKEN_ALPHABET OBS_TEXT

#define EXPECT_BLOCK_DIGITS(head, tail, BLOCK_MACRO)		\
	BLOCK_MACRO(head tail);					\
	BLOCK_MACRO(head "  " tail);				\
	BLOCK_MACRO(head "5a" tail);				\
	BLOCK_MACRO(head "\"" tail);				\
	BLOCK_MACRO(head "=" tail);				\
	BLOCK_MACRO(head "-1" tail);				\
	BLOCK_MACRO(head "0.99" tail);				\
	BLOCK_MACRO(head "dummy" tail);				\
	BLOCK_MACRO(head "4294967296" tail);			\
	BLOCK_MACRO(head "9223372036854775807" tail);		\
	BLOCK_MACRO(head "9223372036854775808" tail);		\
	BLOCK_MACRO(head "18446744073709551615" tail);		\
	BLOCK_MACRO(head "18446744073709551616" tail)

#define EXPECT_BLOCK_SHORT(head, tail, BLOCK_MACRO)		\
	BLOCK_MACRO(head "65536" tail);				\
	BLOCK_MACRO(head "2147483647" tail);			\
	BLOCK_MACRO(head "2147483648" tail);			\
	BLOCK_MACRO(head "4294967295" tail)

/* For ETag and If-None-Match headers */
#define __COMMON_ETAG_IF_NONE_MATCH_BLOCK(head, BLOCK_MACRO)	\
	BLOCK_MACRO(head "\"dummy");				\
	BLOCK_MACRO(head "dummy\"");				\
	BLOCK_MACRO(head "W/ \"dummy\"");			\
	BLOCK_MACRO(head "w/\"dummy\"");			\
	BLOCK_MACRO(head "\"\x00\"");				\
	BLOCK_MACRO(head "\"\x0F\"");				\
	BLOCK_MACRO(head "\"\x7F\"");				\
	BLOCK_MACRO(head "\" \"");				\
	BLOCK_MACRO(head "\"\"\"")

#define COMMON_ETAG_BLOCK(head, BLOCK_MACRO)			\
	__COMMON_ETAG_IF_NONE_MATCH_BLOCK(head, BLOCK_MACRO)

#define COMMON_IF_NON_MATCH_BLOCK(head, BLOCK_MACRO)		\
	BLOCK_MACRO(head "'dummy'");				\
	__COMMON_ETAG_IF_NONE_MATCH_BLOCK(head, BLOCK_MACRO)

/**
 * Reference to a frame of bytes containing the request data to be parsed.
 * Such a frame corresponds to one HTTP request.
 *
 * @len:	frame length in bytes;
 * @str:	pointer to frame;
 * @subtype:	auxiliary field with HTTP/2 frame type that is used only
 *		for HTTP/2 (FUZZ_REQ_H2) requests.
 * @chunks:	points to array of chunks, which kind of represent scattered
 *		data buffers of SKBs
 * @chunk_cnt:	number of detached chunks
 *
  * Used for types HTTP/1 and HTTP/2 requests.
 */
typedef struct {
	unsigned int len;
	unsigned char *str;
	TfwFrameType subtype;
	TfwTestChunk *chunks;
	uint32_t chunk_cnt;
} TfwFrameRec;

#define ALLOWED_FRAMES_CNT  16
#define FRAME_MAX_SIZE	    1048576

void tfw_frames_chunks_free(void);
void tfw_init_frames(void);

/**
 * The special "abstract" structure for buffers with different capacity.
 *
 * @capacity:	number of bytes that the buffer has allocated space for;
 * @size:	actual count of bytes that is currently used.
 *		The @size is never can be greater than @capacity;
 * @data[]:	internal bytes array of size @capacity.
 *
 * It is part of DSL framework for building HTTP/2 requests.
 *
 * Such TfwFramesBuf-like buffer is used to store frames sequentially
 * for generated HTTP/2 messages.
 * One buffer can be used for many frames. Typically, the buffer contains several
 * logically related frames that need to be processed
 * in one call to do_split_and_parse().
 *
 * The such buffer is for HTTP/2 messages only generated by .
 * HTTP/1 messages do not need such storage for their content,
 * as they are now specified using static strings (const char*)
 * stored in the global data segment.
 *
 * There is no need to create TfwFramesBuf structures by yourself.
 * A TfwFramesBuf-like buffer must be created by the DECLARE_FRAMES_BUF macro.
 * Inside the DSL framework, the buffer declared
 * with DECLARE_FRAMES_BUF is cast to the TfwFramesBuf type.
 *
 * Used for HTTP/2 requests only.
 */
typedef struct {
	const unsigned int capacity;
	unsigned int size;
	DECLARE_FLEX_ARRAY(unsigned char, data);
} TfwFramesBuf;

/**
 * DECLARE_FRAMES_BUF - declaring a TfwFramesBuf-like buffer static instance.
 *
 * @name:	identifier of buffer instance;
 * @max_size:	max allowed size in bytes that can be to store in the buffer.
 *		Other words number of bytes that the buffer has allocated space for.
 *
 * Used for HTTP/2 requests only.
 */
#define DECLARE_FRAMES_BUF(name, max_size)					\
	static struct {								\
		const unsigned int capacity;					\
		unsigned int size;						\
		unsigned char data[max_size];					\
	} __attribute__((unused)) name = {.capacity = max_size}


extern TfwFrameRec frames[ALLOWED_FRAMES_CNT];
extern unsigned int frames_cnt;
extern unsigned int frames_max_sz;
extern unsigned int frames_total_sz;
extern TfwFramesBuf *frames_buf_ptr;
extern unsigned char *frame_buf;

/**
 * RESET_FRAMES_BUF - reset current value of @frames_buf_ptr.
 *
 * It is used after the end of the HTTP/2 message definition block.
 *
 * Used for HTTP/2 requests only.
 */
#define RESET_FRAMES_BUF()							\
do {										\
	BUG_ON(!frames_buf_ptr);						\
	frames_buf_ptr = NULL;							\
} while (0)

/**
 * SET_FRAMES_BUF - set @frames_buf_ptr to @frames_buf.
 *
 * @frames_buf:		a TfwFramesBuf-like buffer
 *			declared with DECLARE_FRAMES_BUF macro.
 *
 * It is used before the beginning of the HTTP/2 message definition block.
 *
 * Used for HTTP/2 requests only.
 */
#define SET_FRAMES_BUF(frames_buf)						\
	BUG_ON(frames_buf_ptr);							\
	frames_buf_ptr = (TfwFramesBuf *) &frames_buf;				\
	frames_buf_ptr->size = 0;						\
	bzero_fast(frames_buf_ptr->data, frames_buf_ptr->capacity)

/**
 * FRAMES_BUF_COMMIT - commit data of a newly formed frame.
 *
 * @frame_sz: size of a newly formed frame.
 *
 * Actually, the size of the newly formed frame is simply added
 * to the size of the TfwFramesBuf-like buffer.
 *
 * Used for HTTP/2 requests only.
 */
#define FRAMES_BUF_COMMIT(frame_sz) \
	frames_buf_ptr->size += frame_sz

/**
 * FRAMES_BUF_POS - return pointer to current commited position
 *		    of the TfwFramesBuf-like buffer.
 *
 * Used for HTTP/2 requests only.
 */
#define FRAMES_BUF_POS() \
	(frames_buf_ptr->data + frames_buf_ptr->size)

/**
 * FRAMES_BUF_END - return pointer to the end of the TfwFramesBuf-like buffer.
 *
 * Used for HTTP/2 requests only.
 */
#define FRAMES_BUF_END() \
	(frames_buf_ptr->data + frames_buf_ptr->capacity)

/**
 * __FRAME_BEGIN - generic macro for mark beginning of frame.
 *
 * @type:	HTTP/2 frame type.
 *
 * Used for HTTP/2 requests only.
 */
#define __FRAME_BEGIN(type)							\
do {										\
	BUG_ON(frames_cnt >= ARRAY_SIZE(frames));				\
	frames[frames_cnt].subtype = type;					\
	frame_buf = FRAMES_BUF_POS();						\
} while (0)

static unsigned int frame_sz_tmp __attribute__((unused)) = 0;

/**
 * __FRAME_END - generic macro for mark end of frame.
 *
 * Used for HTTP/2 requests only.
 */
#define __FRAME_END()								\
do {										\
	BUG_ON(frames_cnt >= ARRAY_SIZE(frames));				\
	BUG_ON(!frame_buf);							\
	frame_sz_tmp = frame_buf - FRAMES_BUF_POS();				\
	frames[frames_cnt].str = FRAMES_BUF_POS();				\
	frames[frames_cnt].len = frame_sz_tmp;					\
	frames_max_sz = max(frames_max_sz, frame_sz_tmp);			\
	frames_total_sz += frame_sz_tmp;					\
	++frames_cnt;								\
	FRAMES_BUF_COMMIT(frame_sz_tmp);					\
} while (0)

void write_to_frame_data(char *data, size_t size);
void write_to_frame_index(unsigned long index, unsigned short max,
			unsigned short mask);

/**
 * VALUE - write string to HEADERS-frame (without Haffman encoding).
 *
 * @str:	a C-like static string.
 *
 * Used for HTTP/2 requests only.
 */
#define VALUE(str) \
	write_to_frame_data(str, SLEN(str))

/**
 * VALUE_RAW - write some bytes to HEADERS-frame.
 *
 * @data:	an array with data.
 *
 * Used for HTTP/2 requests only.
 */
#define VALUE_RAW(data) \
	write_to_frame_data(data, sizeof(data))

/**
 * __INDEX - write index to HEADERS-frame like integer representation.
 *
* @index:	index value;
 * @max:	max value of the prefix.
 * @mask:	n-bit pattern ollowed by prefix;
 *
 * There is no need to use __INDEX macro directly.
 * Use XXX_IND-families macro or INDEX macro.
 *
 * Used for HTTP/2 requests only.
 */
#define __INDEX(index, max, mask) \
	write_to_frame_index(index, max, mask)

/**
 * __NAME - write header name filed to HEADERS-frame
 *	    like string representation.
 *
 * @hdr_name:	pointer to string buffer with header name;
 * @mask:	n-bit pattern followed by the header field name.
 *
 * There is no need to use __NAME macro directly.
 * Use XXX_IND-families macro.
 *
 * Used for HTTP/2 requests only.
 */
#define __NAME(hdr_name, mask)							\
do {										\
	*frame_buf++ = mask;							\
	VALUE(hdr_name);							\
} while (0)

/**
 * HEADERS_FRAME_BEGIN - mark beginning of HEADERS-frame.
 *
 * Used for HTTP/2 requests only.
 */
#define HEADERS_FRAME_BEGIN() \
	__FRAME_BEGIN(HTTP2_HEADERS)

/**
 * HEADER - auxiliary macro to separate header fields
 *	    during defining an HTTP/2 message.
 *
 * @header_desc:	a description of header field.
 *
 * Used for HTTP/2 requests only.
 */
#define HEADER(header_desc)							\
do {										\
	BUG_ON(!frame_buf);							\
	header_desc;								\
	BUG_ON(frame_buf > FRAMES_BUF_END());					\
} while (0)

/**
 * HEADERS_FRAME_END - mark end of HEADERS-frame.
 *
 * Used for HTTP/2 requests only.
 */
#define HEADERS_FRAME_END() \
	__FRAME_END()

/**
 * INDEX - specifying indexed representation in the header field.
 *
 * @index:	index value.
 *
 * Used for:
 * - indicating Indexed Header Field Representation in HTTP/2 header field.
 *   Example of usage:	HEADER(INDEX(2));
 * - specify to indexed name in XXX_IND-families macro.
 *   Example of usage:	HEADER(XXX_IND(INDEX(2), VALUE("POST"))).
 *
 * Used for HTTP/2 requests only.
 */
#define INDEX(index)	__INDEX((index), 0x7F, 0x80)

/**
 * NAME - specifying named representation in the header field.
 *
 * Used for XXX_IND-families macro.
 * Example of usage:	HEADER(XXX_IND(NAME(":method"), VALUE("POST"))).
 *
 * Used for HTTP/2 requests only.
 */
#define NAME(data)

/**
 * Literal Header Field with Incremental Indexing.
 * Example of usage:
 * - Indexed Name:	HEADER(INC_IND(INDEX(2), VALUE("POST")));
 * - New Name:		HEADER(INC_IND(NAME(":method"), VALUE("POST"))).
 *
 * Used for HTTP/2 requests only.
 */
#define INC_IND_BY_INDEX(data)	__INDEX((data), 0x3F, 0x40)
#define INC_IND_BY_NAME(data)	__NAME((data), 0x40)
#define INC_IND(name_desc, value_desc)						\
do {										\
	INC_IND_BY_##name_desc;							\
	value_desc;								\
} while (0)

/**
 * Literal Header Field without Indexing.
 * Example of usage:
 * - Indexed Name:	HEADER(WO_IND(INDEX(2), VALUE("POST")));
 * - New Name:		HEADER(WO_IND(NAME(":method"), VALUE("POST"))).
 *
 * Used for HTTP/2 requests only.
 */
#define WO_IND_BY_INDEX(data)	__INDEX((data), 0x0F, 0)
#define WO_IND_BY_NAME(data)	__NAME((data), 0)
#define WO_IND(name_desc, value_desc)						\
do {										\
	WO_IND_BY_##name_desc;							\
	value_desc;								\
} while (0)

/**
 * Literal Header Field Never Indexed.
 * Example of usage:
 * - Indexed Name:	HEADER(NEV_IND(INDEX(2), VALUE("POST")));
 * - New Name:		HEADER(NEV_IND(NAME(":method"), VALUE("POST"))).
 *
 * Used for HTTP/2 requests only.
 */
#define NEV_IND_BY_INDEX(data)	__INDEX((data), 0x0F, 0x10)
#define NEV_IND_BY_NAME(data)	__NAME((data), 0x10)
#define NEV_IND(name_desc, value_desc)						\
do {										\
	NEV_IND_BY_##name_desc;							\
	value_desc;								\
} while (0)

/**
 * Dynamic Table Size Update.
 * Example of usage:		HEADER(SZ_UPD(new_size)).
 *
 * Used for HTTP/2 requests only.
 */
#define SZ_UPD(size) __INDEX((size), 0x1F, 0x20)

/**
 * DATA_FRAME_BEGIN - mark beginning of DATA-frame.
 *
 * Used for HTTP/2 requests only.
 */
#define DATA_FRAME_BEGIN() \
	__FRAME_BEGIN(HTTP2_DATA)

/**
 * DATA - write some bytes to DATA-frame.
 *
 * Used for HTTP/2 requests only.
 */
#define DATA(data)								\
do {										\
	unsigned int data_len;							\
	BUG_ON(!frame_buf);							\
	data_len = SLEN(data);							\
	memcpy_fast(frame_buf, data, data_len);					\
	frame_buf += data_len;							\
	BUG_ON(frame_buf > FRAMES_BUF_END());					\
} while (0)

/**
 * DATA_FRAME_END - mark end of DATA-frame.
 *
 * Used for HTTP/2 requests only.
 */
#define DATA_FRAME_END() \
	__FRAME_END()

/**
 * ADD_HEADERS_FRAME - add HEADERS-frame to @frames.
 *
 * @frame_buf:		a pointer to external buffer with HEADERS-frame payload.
 * @frame_sz:		a size of HEADERS-frame payload in bytes.
 *
 * Used for HTTP/2 requests only.
 */
#define ADD_HEADERS_FRAME(frame_buf, frame_sz)					\
do {										\
	BUG_ON(frames_cnt >= ARRAY_SIZE(frames));				\
	bzero_fast(&frames[frames_cnt], sizeof(frames[0]));			\
	frames[frames_cnt].subtype = HTTP2_HEADERS;				\
	frames[frames_cnt].str = frame_buf;					\
	frames[frames_cnt].len = frame_sz;					\
	frames_max_sz = max(frames_max_sz, frame_sz);				\
	frames_total_sz += frame_sz;						\
	++frames_cnt;								\
} while(0)

/**
 * ADD_DATA_FRAME - add DATA-frame to @frames.
 *
 * @frame_buf:		a pointer to external buffer with DATA-frame payload.
 * @frame_sz:		a size of DATA-frame payload in bytes.
 *
 * Used for HTTP/2 requests only.
 */
#define ADD_DATA_FRAME(frame_buf, frame_sz)					\
do {										\
	BUG_ON(frames_cnt >= ARRAY_SIZE(frames));				\
	bzero_fast(&frames[frames_cnt], sizeof(frames[0]));			\
	frames[frames_cnt].subtype = HTTP2_DATA;				\
	frames[frames_cnt].str = frame_buf;					\
	frames[frames_cnt].len = frame_sz;					\
	frames_max_sz = max(frames_max_sz, frame_sz);				\
	frames_total_sz += frame_sz;						\
	++frames_cnt;								\
} while(0)

/**
 * ASSIGN_FRAMES_FOR_H2 - assign HTTP/2 frame(s) to @frames.
 *
 * @frames_definition:	a description of HTTP/2 frame(s).
 *
 * Used for HTTP/2 requests only.
 */
#define ASSIGN_FRAMES_FOR_H2(frames_definition)					\
do {										\
	tfw_init_frames();							\
	SET_FRAMES_BUF(frames_buf);						\
	frames_definition;							\
	RESET_FRAMES_BUF();							\
} while(0)

DECLARE_FRAMES_BUF(frames_buf, 3 * 1024);

int split_and_parse_n(unsigned char *str, uint32_t type, uint32_t len,
			uint32_t chunk_size, TfwTestChunk **fchunks);

extern unsigned int chunk_size_index;
extern TfwHttpReq *req, *sample_req;
extern TfwHttpResp *resp;
extern TfwH2Conn conn;
extern TfwStream stream;
extern TfwClient client;

int set_sample_req(unsigned char *str);

void test_case_parse_prepare_http(char *str);
void test_case_alloc_h2(void);
void test_case_cleanup_h2(void);
void test_case_parse_prepare_h2(void);
int do_split_and_parse(int type, int chunk_mode);

int validate_data_fully_parsed(int type, size_t sz_diff);

static inline void
test_http2_parser_setup_fn(void)
{
	test_case_alloc_h2();
	test_case_parse_prepare_h2();
}

static inline void
test_http2_parser_teardown_fn(void)
{
	test_req_resp_cleanup();
	test_case_cleanup_h2();
}

#define __TRY_PARSE_EXPECT_PASS(type, sz_diff, chunk_mode)		\
chunk_size_index = 0;							\
while (({								\
	int _err = do_split_and_parse(type, chunk_mode);		\
	if (_err == T_BLOCK_WITH_FIN || _err == T_BLOCK_WITH_RST	\
	    || _err == T_BLOCK || _err == T_POSTPONE || _err == T_BAD	\
	    || _err == T_DROP						\
	    || !validate_data_fully_parsed(type, sz_diff))		\
		TEST_FAIL("can't parse %s (code=%d)\n",			\
			  (type == FUZZ_REQ	    			\
			   || type == FUZZ_REQ_H2			\
			   ? "request" : "response"),			\
			  _err);					\
	__fpu_schedule();						\
	_err == T_OK;							\
}))

#define TRY_PARSE_EXPECT_PASS(type, chunk_mode) \
	__TRY_PARSE_EXPECT_PASS(type, 0, chunk_mode)

#define TRY_PARSE_EXPECT_BLOCK(type, chunk_mode)			\
chunk_size_index = 0;							\
while (({								\
	int _err = do_split_and_parse(type, chunk_mode);		\
	if (_err == T_OK)						\
		TEST_FAIL("%s is not blocked as expected\n",		\
			  (type == FUZZ_REQ				\
			   || type == FUZZ_REQ_H2			\
			   ? "request" : "response"));			\
	__fpu_schedule();						\
	_err == T_BLOCK_WITH_FIN || _err == T_BLOCK_WITH_RST ||		\
	_err == T_BLOCK || _err == T_POSTPONE || _err == T_BAD ||	\
	_err == T_DROP;							\
}))

#define PRINT_REQ(str)	TEST_LOG("h1 req: [%s]\n", str)

#define PRINT_REQ_H2()							\
do {									\
    BUG_ON(frames_cnt == 0);						\
    print_hex_dump(KERN_INFO, TEST_BANNER "h2 req: ", DUMP_PREFIX_NONE,	\
		   32, 1, frames[0].str, min_t(size_t, frames[0].len, 32U),\
		   true);						\
} while (0)

#define __FOR_REQ(str, sz_diff, chunk_mode)				\
	PRINT_REQ(str);							\
	test_case_parse_prepare_http(str);				\
	__TRY_PARSE_EXPECT_PASS(FUZZ_REQ, sz_diff, chunk_mode)

#define FOR_REQ(str)							\
	__FOR_REQ(str, 0, CHUNK_ON)

#define FOR_REQ_H2(frames_definition)					\
	ASSIGN_FRAMES_FOR_H2(frames_definition);			\
	PRINT_REQ_H2();							\
	test_req_resp_cleanup();					\
	tfw_h2_context_clear(conn.h2);					\
	test_case_parse_prepare_h2();					\
	TRY_PARSE_EXPECT_PASS(FUZZ_REQ_H2, CHUNK_ON)

#define FOR_REQ_H2_HPACK(frames_definition)				\
	ASSIGN_FRAMES_FOR_H2(frames_definition);			\
	PRINT_REQ_H2();							\
	TRY_PARSE_EXPECT_PASS(FUZZ_REQ_H2, CHUNK_ON)

#define EXPECT_BLOCK_REQ(str)						\
	PRINT_REQ(str);							\
	test_case_parse_prepare_http(str);				\
	TRY_PARSE_EXPECT_BLOCK(FUZZ_REQ, CHUNK_ON)

#define EXPECT_BLOCK_REQ_H2(frames_definition)				\
	ASSIGN_FRAMES_FOR_H2(frames_definition);			\
	PRINT_REQ_H2();							\
	test_req_resp_cleanup();					\
	tfw_h2_context_clear(conn.h2);					\
	test_case_parse_prepare_h2();					\
	TRY_PARSE_EXPECT_BLOCK(FUZZ_REQ_H2, CHUNK_ON)

#define EXPECT_BLOCK_REQ_H2_HPACK(frames_definition)			\
	ASSIGN_FRAMES_FOR_H2(frames_definition);			\
	PRINT_REQ_H2();							\
	TRY_PARSE_EXPECT_BLOCK(FUZZ_REQ_H2, CHUNK_ON)

#define __FOR_RESP(str, sz_diff, chunk_mode)				\
	TEST_LOG("=== response: [%s]\n", str);				\
	test_case_parse_prepare_http(str);				\
	__TRY_PARSE_EXPECT_PASS(FUZZ_RESP, sz_diff, chunk_mode)

#define FOR_RESP(str)	__FOR_RESP(str, 0, CHUNK_ON)

#define EXPECT_BLOCK_RESP(str)						\
	TEST_LOG("=== response: [%s]\n", str);				\
	test_case_parse_prepare_http(str);				\
	TRY_PARSE_EXPECT_BLOCK(FUZZ_RESP, CHUNK_ON)

#define EXPECT_TFWSTR_EQ(tfw_str, cstr)					\
	EXPECT_TRUE(tfw_str_eq_cstr(tfw_str, cstr, strlen(cstr), 0))

void test_string_split(const TfwStr *expected, const TfwStr *parsed);

TfwStr get_next_str_val(TfwStr *str);

#endif /* __TFW_HTTP_PARSER_COMMON_H__ */
