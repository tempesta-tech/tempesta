# Common utilities for Tempesta scripts
#
# Copyright (C) 2016-2024 Tempesta Technologies, Inc.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License,
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59
# Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Resolve root to absolute path which is handy for kernel.
# pwd is used instead of readlink to avoid symlink resolution.
TFW_ROOT=$(dirname "$0")
pushd "$TFW_ROOT/.." > /dev/null
TFW_ROOT="$(pwd)"
popd > /dev/null

declare -r TFW_NAME=`basename $0` # program name (comm name in ps)
declare -r TFW_NETDEV_PATH="/sys/class/net/"
declare -r TFW_SCRIPTS="$TFW_ROOT/scripts"
declare -r CPUS_N=$(grep -c processor /proc/cpuinfo)
declare -r IRQB_CONF_PATH="/etc/default/irqbalance"
declare -r SYSD_IRQB_PATH="/lib/systemd/system/irqbalance.service"
declare -r BAN_CONF_VAR="TFW_BAN_IRQS"
declare -a IRQS_GLOB_LIST

ensure_command()
{
	if ! hash "$1" &> /dev/null
	then
		echo "'$1' command not found"
		exit 1
	fi
}

ensure_command bc
calc()
{
	echo "$1" | bc -iq | tail -1
}

# Assigned IRQs can be reassigned by irqbalance. To avoid this, assigned
# vectors should be added to irqbalance config with '--banirq' option.
irqbalance_ban_irqs()
{
	args_str=""
	sysd_conf_var="ExecStart"

	for irq in ${IRQS_GLOB_LIST[@]}; do
		args_str=$args_str"--banirq=$irq "
	done

	conf_var_str="$BAN_CONF_VAR=$args_str"
	perl -i.orig -ple '
		if (/^'"$BAN_CONF_VAR"'=.*$/) {
			$_ = "'"$conf_var_str"'";
			$found = 1;
		}
		END {
			unless ($found) {
				open(CONFIG, ">>", $ARGV);
				select(CONFIG);
				print("\n# Do not edit this variable. It is"
				    . " automatically generated by start\n#"
				    . " script of Tempesta FW and is intended"
				    . " to avoid reassigning of specified"
				    . " IRQs.");
				printf("%s\n", "'"$conf_var_str"'");
				select(STDOUT);
			}
		}
	' $IRQB_CONF_PATH

	perl -i.orig -ple '
		if (/^('"$sysd_conf_var"'=.*)$/) {
			unless (/.*\$'"$BAN_CONF_VAR"'\b.*/) {
				$_ = $1 . " \$'"$BAN_CONF_VAR"'";
			}
		}
	' $SYSD_IRQB_PATH

	systemctl daemon-reload >/dev/null
	systemctl restart irqbalance.service >/dev/null
}

# This function prepares cpu mask for RSS and RPS.
# It takes into account that we can't calculate
# value, which is greater when (1 << 63) and can't
# wtite in the rps_cpus/smp_affinity value, which
# is greater then (1 << 32) -1 (we need to write it
# using comma).
make_cpu_mask()
{
	delta=$1
	mask32=$2
	val=$3
	cond=$4
	res=0

	# If delta is less than 32, we can directly calculate
	# and write this value. For RPS it will looks like
	# fff..... and for RSS it will looks like 1000....
	if [[ $delta -lt 32 ]]; then
		res=`printf %x $(( $((1 << delta )) - val))`
	else
		res="$mask32"
	fi
	delta=$(( delta - 32 ))

	# For RPS cond is 0, because (1 << delta) - val is zero
	# and we don't need to write most significat zero bits.
	while [[ $delta -ge $cond ]]
	do
		if [[ $delta -lt 32 ]]; then
			res=`printf %x $(( $((1 << delta )) - val))`",$res"
		else
			res="$mask32,$res"
		fi
		delta=$(( delta - 32 ))
	done

	echo "$res"
}

make_cpu_rss_mask()
{
	delta=$1
	# Enable only one CPU (1 << delta)
	mask32="00000000"
	# Used to calculate (1 << delta) - $val to
	# implement only one common functionfor RPS and RSS
	val=0
	cond=0

	echo `make_cpu_mask $delta $mask32 $val $cond`
}

make_cpu_rps_mask()
{
	delta=$1
	# enable all CPUs, which is less than (1 << delta) - 1
	mask32="ffffffff"
	# used to calculate (1 << delta) - $val to
	# implement only one common functionfor RPS and RSS
	val=1
	cond=1

	echo `make_cpu_mask $delta $mask32 $val $cond`
}

distribute_queues()
{
	dev=$1
	RXQ_MAX=$2
	type=$3

	# Set maximum number of available channels for better
	# packets hashing.
	res=$(ethtool -L $dev $type $RXQ_MAX 2>&1)
	if [ $? -ne 0 -a -z "$(echo $res | grep -P '^rx unmodified, ignoring')" ]
	then
		echo "Error: cannot set new queues count for $dev: $res"
		return
	fi

	# Wait for the interface reconfiguration.
	opstate="$TFW_NETDEV_PATH/$dev/operstate"
	while [ "$(cat $opstate)" = "down" ]; do
		sleep 1
	done

	# Interrupts may not have interface-like description in
	# '/proc/interrupts' - so, to find the vectors we also need
	# to check the MSI directory for device.
	dev_irqs_path="/sys/class/net/$dev/device/msi_irqs"
	irqs=($(grep $dev /proc/interrupts | sed -e 's/\s*\|:.*//g'))
	if [ -z "$irqs" -a -d $dev_irqs_path ]; then
		irqs=($(ls $dev_irqs_path))
	fi

	if [ -z "$irqs" ]; then
		echo "Error: cannot find interrupts for $dev"
		return
	fi

	# Skip the first IRQ since this is general async interrupt
	# for device (not assigned to any of the queues).
	irqs=(${irqs[@]:1})
	irq0=${irqs[0]}
	for i in ${irqs[@]}; do
		# Wrap around CPU mask if number of queues is
		# larger than CPUS_N.
		if [[ $(calc "$i - $irq0") -gt $CPUS_N ]]; then
			irq0=$i;
		fi
		delta=$(( i - irq0 ))
		mask=`make_cpu_rss_mask $delta`
		echo "$mask" > "/proc/irq/$i/smp_affinity"
	done

	IRQS_GLOB_LIST=(${irqs[@]})
	if [ ${#IRQS_GLOB_LIST[@]} -ne 0 -a -f $SYSD_IRQB_PATH \
	     -a -f $IRQB_CONF_PATH ]; then
		systemctl status irqbalance.service >/dev/null
		[ $? -ne 0 ] || irqbalance_ban_irqs
	fi

	echo "0"
}

distribute_rx_queues()
{
	dev=$1
	min_queues=$2
	error="Rx queues for $dev not found"

	queues_str=$(ethtool -l $dev 2>/dev/null \
		     | grep -m 1 RX | sed -e 's/RX\:\s*//')
	queues=$(printf '%d' "$queues_str" 2>/dev/null)
	if [ -n "$queues" -a ${queues:-0} -gt $min_queues ]; then
		# Switch off RPS for multi-queued interfaces.
		for rx in $TFW_NETDEV_PATH/$dev/queues/rx-*; do
			echo 0 > $rx/rps_cpus
		done

		error=`distribute_queues $dev $queues "rx"`
	fi

	echo "$error"
}

distribute_combined_queues()
{
	dev=$1
	min_queues=$2
	error="Combined queues for $dev not found"

	queues_str=$(ethtool -l $dev 2>/dev/null \
		     | grep -m 1 Combined | sed -e 's/Combined\:\s*//')
	queues=$(printf '%d' "$queues_str" 2>/dev/null)
	if [ -n "$queues" -a ${queues:-0} -gt $min_queues ]; then
		# Switch off RPS for multi-queued interfaces.
		for rx in $TFW_NETDEV_PATH/$dev/queues/rx-*; do
			echo 0 > $rx/rps_cpus
		done

		error=`distribute_queues $dev $queues "combined"`
	fi

	echo "$error"
}

# Enable RSS for networking interfaces. Enable RPS for those devices which
# doesn't have enough hardware queues.
tfw_set_net_queues()
{
	devs=$1
	min_queues=$(calc "$CPUS_N / 2")
	cpu_mask=`make_cpu_rps_mask $CPUS_N`

	# Iterate over all existing devices and to setup RSS or
	# if it is not supported RPS for each device.
	for dev in $devs; do
		echo "...distribute $dev rx queues"
		# First try to setup RX queues.
		error=`distribute_rx_queues $dev $min_queues`
		if [[ "$error" != "0" ]]; then
			echo "$error"
			echo "...distribute $dev combined queues"
			# If RX queues setup fails try to setup
			# combined queues.
			error=`distribute_combined_queues $dev $min_queues`
		fi
		if [[ "$error" != "0" ]]; then
			echo "$error"
			echo "...enable RPS on $dev"
			for rx_queue in $TFW_NETDEV_PATH/$dev/queues/rx-*
			do
				echo $cpu_mask > $rx_queue/rps_cpus
			done
		fi
	done
}

tfw_irqbalance_revert()
{
	systemctl status irqbalance.service >/dev/null
	if [ $? -eq 0 -a -f $IRQB_CONF_PATH ]; then
		echo "...revert irqbalance config"
		perl -i.orig -ple '
			s/^('"$BAN_CONF_VAR"'=).*$/$1/;
		' $IRQB_CONF_PATH
		systemctl restart irqbalance.service >/dev/null
	fi
}

check_dmesg()
{
	msg=$1

	# Exclude debug level to work in the same way for all the build types.
	dmesg --level=emerg,alert,crit,err,warn,notice,info | tail | grep "$msg"
}
