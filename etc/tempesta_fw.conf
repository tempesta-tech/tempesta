#
# Tempesta FW configuration file template.
#
# See Wiki https://github.com/tempesta-tech/tempesta/wiki/Configuration
# for more configuration examples and use cases.
#
# TAG: sched.
#
# Specifies the scheduler used to distribute the load among servers within
# a group.
#
# Syntax:
#   sched SCHED_NAME [OPTIONS];
#
# Include directive
# You can include config paths via add !include /some/path/*
#   all config files with subdirectories will appear with its content in
#   new generated config file on default location. Tempesta config file 
#   now is only generated by template every time tempesta.sh starts
# 
# !include /etc/tempesta/sites/*
#
#
# SCHED_NAME is a name of a scheduler module that distributes the load
# among servers within a group. There are two schedulers available:
#   - 'ratio' (default)
#       Balances the load across servers in a group based on each server's
#       weight. Requests are forwarded more to servers with more weight,
#       and less to servers with less weight. As a result, each server
#       in a group receives an optimal load. In default configuration
#       where weights are not specified, servers weights are considered equal,
#       and the scheduler works in pure round-robin fashion.
#   - 'hash'
#       Chooses a server based on a URI/Host hash of a request.
#       Requests are still distributed uniformly, but a request with the same
#       URI/Host is always sent to the same server.
#
# OPTIONS are optional. Not all schedulers have additional options.
#
# 'ratio' scheduler may have the following options:
#   - 'static'
#       The weight of each server in a group is defined statically
#       with [weight=<NN>] option of the 'server' directive. This is the
#       default Ratio scheduler option.
#   - 'dynamic'
#       The weight of each server in a group is defined dynamically.
#       Specific type of dynamic weight is specified with additional options:
#       - 'minimum' - The current minimum response time from a server;
#       - 'maximum' - The current maximum response time from a server;
#       - 'average' - The current average response time from a server;
#       - 'percentile [<NN>]' - The current response time from a server
#           that is within specified percentile. The percentile may be
#           one of 50, 75, 90, 95, 99. If none is given, then the default
#           percentile of 90 is used.
#       If a specific type of dynamic weight is not specified, then
#       the default type of 'average' is used.
#   - 'predict'
#       The weight of each server in a group is predicted dynamically
#       for a time in the future, based on server's behavior in the past.
#       Additional options include those that are defined for 'dynamic' weight,
#       as well as the following options:
#       - 'past' - Period of time (in seconds) to keep past response time
#           values from a server. The default value is 30 seconds.
#       - 'rate' - Rate (times per second) of retrieval of past response time
#           values. The default value is 20 times per second.
#       - 'ahead' - Period of time (in seconds) for which to make a prediction;
#           It can't be more than half of **past**. The default value is 15
#           seconds.
#
# Note that there's also the HTTP scheduler. It dispatches requests among
# server groups only. Round-robin or hash scheduler must be used to select
# a server within a group.
#
# A group can be either explicit, defined with 'srv_group' directive, or
# implicit. Only one 'sched' directive is allowed per group. A scheduler
# defined for the implicit group becomes the scheduler for an explicit
# group defined with 'srv_group' directive if the explicit group is missing
# the 'sched' directive.
#
# Default:
#   sched ratio;
#

# TAG: server.
#
# Specifies an IP address/port of a back-end HTTP server.
#
# Syntax:
#   server IPADDR[:PORT] [conns_n=N] [weight=N];
#
# IPADDR may be either IPv4 or IPv6 address, hostnames are not allowed.
# IPv6 address must be enclosed in square brackets (e.g. "[::0]" but not "::0").
# PORT defaults to 80 if not set.
#
# 'conns_n=N' is the number of parallel connections to the server.
# The N defaults to 32 if the option is not specified.
#
# 'weight=N' is the static weight of the server. The weight must be in
# the range of 1 to 100. If not specified, then the default weight of 50
# is used with the static ratio scheduler. Just the weight that differs
# from default value may be specified for convenience.
#
# Multiple back-end servers may be specified, for example:
#   server 10.1.0.1:80;
#   server [fc00::1]:80;
#
# Default:
#   None.
#

#
# TAG: nonidempotent
#
# Defines a request that is considered non-idempotent.
#
# Syntax:
#   nonidempotent <METHOD> <OP> <string>;
#
# <METHOD> is one of supported HTTP methods, such as GET, HEAD, POST, etc.
# <OP> is a string matching operator, one of 'eq', 'prefix', 'suffix', or '*'.
# <string> is a verbatim string matched against URL in a request.
#
# One or more of this directive may be specified. The directives apply to
# one or more locations, either specific or global (see 'location' directive).
#
# Example:
#    nonidempotent GET prefix "/users/";
#    nonidempotent POST prefix "/users/";
#    nonidempotent GET suffix "/data";
#
# Default:
#   A non-idempotent request in defined as a request that has an unsafe method.
#

#
# TAG: server_connect_retries
#
# Defines the maximum number of attempts to reconnect with a server.
#
# Syntax:
#   server_connect_retries NUM;
#
# If a connection with a server is not re-established after the specified
# number of attempts, then the connection is considered dead. Outstanding
# requests in the connection are re-scheduled to other servers and/or
# connections.
#
# Default:
#   server_connect_retries 10;
#

#
# TAG: server_forward_retries
#
# Defines the maximum number of attempts to re-forward a request to a server.
#
# Syntax:
#   server_forward_retries NUM;
#
# Default:
#   server_forward_retries 5;
#

#
# TAG: server_forward_timeout
#
# Defines the maximum time frame within which a request may still be forwarded.
#
# Syntax:
# server_forward_timeout SECONDS;
#
# Default:
# server_forward_timeout 60;
#

#
# TAG: server_retry_nonidempotent
#
# Defines that non-idempotent requests should be re-forwarded.
#
# Syntax:
#   server_retry_nonidempotent;
#
# Default:
#   Do not re-forward non-idempotent requests.
#

#
# TAG: server_queue_size
#
# Defines the size of the forwarding queue in a server connection.
#
# Syntax:
#   server_queue_size 600;
#
# This is the maximum number of requests that may be in the forwarding
# queue of a server connection at any given time.
#
# Default:
#   server_queue_size 1000;
#

#
# TAG: grace_shutdown_time
#
# Defines the timeout in seconds for graceful server removing during
# reconfiguration.
#
# Syntax:
#   grace_shutdown_time 5;
#
# If a server is deleted from the configuration, but is still alive, then
# let all current sessions and requests to finish, but do not schedule new
# sessions/requests to the server.
#
# Default:
#   grace_shutdown_time 0;
#

# TAG: srv_group
#
# Groups multiple backend servers into a single unit of load balancing.
# All backend servers within a group are treated as interchangeable.
# The load is distributed evenly over all servers within a single group.
# If some server goes offline, other members of the group take its load.
#
# Syntax:
#   srv_group NAME {
#       server IPADDR[:PORT] [conns_n=N];
#       ...
#   }
#
# NAME is a unique identifier of the group that may be used to refer it later.
#
# IPADDR[:PORT] is the IPv4 or IPv6 address of the server (see: server).
# conns_n=N is the number of parallel connections to the server (see: server).
#
# Examples:
#   srv_group static_storage {
#       server 10.10.0.1:8080;
#       server 10.10.0.2:8080;
#       server [fc00::3]:8081 conns_n=1;
#       sched hash;
#   }
#
# Default:
#   There is a special group called "default". All 'server' entries defined
#   outside an 'srv_group' added to the "default" group implicitly.
#

# TAG: http_chain
#
# Block of HTTP content-based load balancing rules. List of such linked
# blocks (chains), that contain rules, represent HTTP table.
# The HTTP table is instructed to send HTTP requests to a virtual host
# based on the contents of an HTTP request field, such as URI, Host,
# headers, etc.
#
# Syntax:
#   http_chain {
#       [ FIELD [HDR_NAME] == (!=) ARG ] -> ACTION [ = VAL];
#       ...
#   }
#
# FIELD is an HTTP request field such as uri, host, etc.
# Supported FIELD keywords:
#   - 'uri'
#       Only a part of URI is looked at that contains the path and the query
#       string if any (e.g. "/abs/path.html?query&key=val#fragment").
#   - 'host'
#       The host part from URI in HTTP request line, or the value of Host
#       header field. The Host part in URI takes priority over the Host header
#       field value.
#   - 'method'
#       HTTP request method. Supported ARG values for this field are: "copy",
#       "delete", "get", "head", "lock", "mkcol", "move", "options", "patch",
#       "post", "propfind", "proppatch", "put", "trace", "unlock", "purge".
#   - 'hdr'
#       The content of specific HTTP header. In this case HDR_NAME field is
#       used to specify the name of header; the value of header should be
#       specified in ARG. Matching of special headers: "X-Forwarded-For",
#       "If-None-Match", "Referer", "Cookie", "User-Agent", "Content-Type",
#       "Connection", "Host" - is accelerated; processing of other headers
#       may be slow as it requires walking over all headers of an HTTP
#       request. Also, suffix OP is not supported for not special headers.
#   - 'mark'
#       The value of netfilter mark of request's skb.
#
# ARG is an argument (such as "/foo/bar.html", "example.com", etc.) for
# comparison with FIELD. The type of comparison for FIELD and ARG depends
# on "==" ("!=") sign and on wildcard existence in ARG:
#   "==": "ARG" => eq / "ARG*" => eq_prefix / "*ARG" => eq_suffix.
#   "!=": "ARG" => non_eq / "ARG*" => non_eq_prefix / "*ARG" => non_eq_suffix.
# Types of comparison operations:
#   - 'eq'              - FIELD is fully equal to the string specified in ARG.
#   - 'non_eq'          - FIELD is not equal to the string specified in ARG.
#   - 'eq_prefix'       - FIELD starts with the string specified in ARG.
#   - 'non_eq_prefix'   - FIELD doesn't starts with the string specified in ARG.
#   - 'eq_suffix'       - FIELD ends with the string specified in ARG.
#   - 'non_eq_suffix'   - FIELD doesn't ends with the string specified in ARG.
#
# ACTION is a rule action with appropriate type; possible types are:
#   - 'vhost' reference
#       Rule with such action pass the request to specified virtual host
#       (must be defined earlier in configuration file).
#   - 'chain' reference
#       Rule redirects request to other HTTP chain
#       (must be defined earlier and must not be the same as current).
#   - 'mark'
#       Rule sets netfilter marks into all skbs for all matched requests.
#   - 'block'
#       Rule blocks all matched requests.
#
# VAL is possible value for specified action; only 'mark' action is allowed to
# have value (unsigned integer type).
#
# Rule entry is a single instruction for HTTP table that says: take the FIELD
# of http request, compare it with ARG. If they match, then apply rule ACTION
# (with possible VAL) to that request.
# For every HTTP request, HTTP table executes all rule instructions in all
# linked HTTP chains (beginning from the main chain) sequentially until it finds
# a match. If no match is found, then the request is dropped.
#
# Default match rule can be specified. Its syntax looks like this:
#
# Syntax:
#     -> ACTION;
#
# This rule works as last resort option, and if specified it applies designated
# action to requests that didn't match any more specific rule. As all match
# rules are processed in sequential order, this rule must come last to serve
# the intended role.
# One main HTTP chain (without name) must be specified after all other chains in
# configuration file. If no main chain is specified, it is created implicitly.
# In this case one default match rule pointing to "default" virtual host will be
# created in implicit main chain if default virtual host is present in
# configuration and if such default rule (with "default" virtual host) have not
# been specified explicitly in any chain in configuration.
# User can explicitly create main HTTP chain with empty list of rules, which
# means the complete absence of rules - all incoming requests will be dropped
# in such configuration.
#
# Example:
#   srv_group static { ... }
#   srv_group nts_app { ... }
#   srv_group foo_app { ... }
#   srv_group bar_app { ... }
#   srv_group default { ... }
#
#   vhost base {
#       proxy_pass static;
#       ...
#   }
#   vhost app {
#       proxy_pass default;
#       location prefix "?" {
#           proxy_pass foo_app;
#           ...
#       }
#       location prefix "/static/" {
#           proxy_pass static;
#           ...
#       }
#       ...
#   }
#   vhost heavy {
#       proxy_pass bar_app backup=foo_app;
#       ...
#   }
#   vhost nts {
#       proxy_pass nts_app backup=bar_app;
#       ...
#   }
#
#   http_chain example {
#                                         -> mark = 7;
#                                         -> heavy;
#   }
#   http_chain stat {
#                                         -> mark = 6;
#                                         -> base;
#   }
#   http_chain natsys {
#       host == "static.*"                -> stat;
#       host == "*.example.com"           -> example;
#                                         -> mark = 5;
#                                         -> nts;
#   }
#   http_chain {
#       mark == 1                          -> app;
#       mark == 2                          -> block;
#       hdr "Connection" == "keep-alive"   -> heavy;
#       hdr "Host" == "bar.*"              -> heavy;
#       hdr "Host" == "*natsys-lab.com"    -> natsys;
#       hdr "Host" == "bar.natsys-lab.com" -> mark = 3;
#       hdr "X-Custom-Bar-Hdr" == "*"      -> mark = 4;
#       uri == "*.php"                     -> app;
#       host == "static.*"                 -> app;
#       host == "*tempesta-tech.com"       -> base;
#       host == "foo.example.com"          -> base;
#                                          -> app;
#   }
#
# Configuration order 'srv_groups/servers -> vhosts -> http_chains'
# is mandatory.
#
# Default:
#   See description of main HTTP chain and default rule above.
#

# TAG: keepalive_timeout
#
# Syntax:
#   keepalive_timeout TIMEOUT
#
# TIMEOUT is a timeout in seconds during which a keep-alive client connection
# will stay open in Tempesta. The zero value disables keep-alive client
# connections.
#
# Default:
#   keepalive_timeout 75;
#

# TAG: listen
# 
# Tempesta FW listening address.
#
# Syntax:
#   listen PORT | IPADDR[:PORT] [proto=http|https|h2]
#
# IPADDR may be either an IPv4 or IPv6 address, no host names allowed.
# IPv6 address must be enclosed in square brackets (e.g. "[::0]" but not "::0").
#
# If only PORT is given, then the address 0.0.0.0 (but not [::1]) is used.
# If only IPADDR is given, then the default HTTP port 80 is used.
#
# It is allowed to specify the type of listening socket via the 'proto'. At the
# moment following values for 'proto' attribute are supported: 'http' (means
# HTTP/1.1 over TCP), 'https' (means HTTP/1.1 over TLS) and 'h2' (means HTTP/2
# over TLS). If 'proto' option is absent, then 'proto=http' is supposed by
# default.
#
# Tempesta FW opens one socket for each 'listen' entry, so it may be repeated
# to listen on multiple addresses/ports. For example:
#   listen 80;
#   listen 443 proto=h2;
#   listen [::0]:80;
#   listen 127.0.0.1:8001;
#   listen [::1]:8001;
#
# Default:
#   listen 80;
#

# TAG: block_action
#
# Syntax:
#   block_action MSG_TYPE ACTION [OPTIONS];
#
# MSG_TYPE specifies type of incoming message (e.g. malicious).
# The following keywords are supported:
#   - 'error' - Action must be applied only to malformed messages.
#   - 'attack' -  Action must be applied only to malicious (attack) messages.
#
# ACTION specifies operation which Tempesta must perform with specified
# message type. The following ACTION keywords are supported:
#   - 'drop' - Tempesta must block message silently (response won't
#       be generated).
#   - 'reply' - Response with appropriate error status will be sent to client.
#
# Currently supported OPTIONS:
#   - 'nolog' - logging information about error/attack situation is disabled.
#
# Default:
#   block_action error reply;
#   block_action attack drop;
#

# TAG: response_body
#
# Syntax:
#   response_body status_code file;
#
# Specifies a path to file with page body for defined HTTP status_code;
# status_code must be present in three-digit form ("502", "403"), or
# in form of codes group ("4*" or "5*").
#

# TAG: tls_certificate
# TAG: tls_certificate_key
#
# Provides the necessary support for HTTPS.
#
# Syntax:
#  tls_certificate file;
#
# Specifies a file with the certificate in the PEM format.
#
# Syntax:
#  tls_certificate_key file;
#
# Specifies a file with the secret key in the PEM format.
#

# TAG: tls_tickets
#
# Enable TLS session tickets generation and processing for faster TLS
# connection establishing as defined in RFC 5077. Enabled by default, allowed
# in vhost scope.
#
# Syntax:
#   tls_tickets [disable|enable] [secret=SECRET] [lifetime=N]
#
# The option provides performance improvement without security degradation,
# thus enabled by default. If this is not the desired behaviour, Session
# Tickets can be switched off by 'disable' argument.
#
# In default configuration a random built key is used to generate TLS Sessions
# Ticket keys, so every vhost has its own unique keys and keys are different
# on different TempestaFW installations. If 'secret' is provided, it's used
# as master key to generate Session Ticket keys equally on different TempestaFW
# nodes running the same configuration. In this case TLS session established
# on one TempestaFW node can be resumed on the others. Note that local time is
# mixed into the generated keys, so all TempestaFW nodes should use the same
# time settings. Even if multiple vhosts share the same secret, generated
# tickets keys will differ for them.
#
# Session Ticket keys are constantly rotated, to reduce number of tickets
# encrypted with the same key. Default rotation period is set to 1 hour.
# The rotation period can be exteded by 'lifetime' option.
#
# Example:
#   tls_tickets disable;
#   tls_tickets secret="f00)9eR59*_/22" lifetime=7200;
#
# Default:
#   tls_tickets;
#

# TAG: cache
#
# Web content caching mode:
#  - "0"
#       No caching, pure proxying mode;
#  - "1"
#       Sharding, each NUMA node contains independent shard of whole cache.
#       This mode has the smallest memory requirements;
#  - "2"
#       Replicated, each NUMA node has whole replica of the cache.
#       It requires more RAM, but delivers the highest performance.
#       This is default mode.
#
# Syntax:
#   cache [0-2]
#
# Default:
#   cache 2;
#

# TAG: cache_db
# 
# Path to a cache database used as a storage for Tempesta FW Web cache.
#
# Syntax:
#   cache_db PATH
#
# The PATH must be absolute and the directory must exist.
# Also, the PATH should not end with a slash (e.g. "/foo/bar/").
#
# Spaces and other special characters must be escaped with a backslash.
# Alternatively, the whole path may be enclosed to double quotes.
# For example:
#   cache_db /var/foo\ bar\ baz/cache.tdb;
#   cache_db "/var/weird !;% name/foo.tdb";
#
# Default:
#   cache_db /opt/tempesta/db/cache.tdb;
#

# TAG: cache_size
#
# Size of file(s) created by Tempesta FW within cache_dir.
#
# Syntax:
#   cache_size SIZE
#
# SIZE is specified in bytes, suffixes like 'MB' are not supported yet.
# Also, the number must be a multiple of 2MB (Tempesta DB extent size).
# Allowed sizes are from 16MB to 128GB.
#
# Default:
#   cache_size 268435456;  # 256MB
#

# TAG: cache_bypass
#
# Bypass cache. Do not serve a request from cache. Do not store the
# response to that request in cache.
#
# Syntax:
#   cache_bypass <OP> <string>;
#
# <OP> is a match operator, one of 'eq', 'prefix', 'suffix', or '*'.
# <string> is a verbatim string matched against URL in a request.
#
# Default:
#   None.
#

# TAG: cache_fulfill
#
# Use cache. Serve a request from cache. If the response is not in cache,
# then forward it to a back end server, and store the response in cache.
# Update the cached response when necessary.
#
# Syntax:
#   cache_fulfill <OP> <string>;
#
# <OP> is a match operator, one of 'eq', 'prefix', 'suffix', or '*'.
# <string> is a verbatim string matched against URL in a request.
#
# Default:
#   None.
#

# TAG: resp_hdr_add
#
# Append a user-defined header to HTTP response message before forwarding
# it to client.
#
# Syntax:
#   resp_hdr_add <name> <value>;
#
# Example:
#   resp_hdr_add Expires "Thu, 15 Apr 2020 20:00:00 GMT"
#
# Default:
#   None.
#

# TAG: resp_hdr_set
#
# Replace or remove a user-defined header from HTTP response message before
# forwarding it to client.
#
# Syntax:
#   resp_hdr_set <name> <value>;
#   resp_hdr_set <name>;
#
# Example:
#   resp_hdr_add Expires "Thu, 15 Apr 2020 20:00:00 GMT"
#   resp_hdr_add Expires
#
# Default:
#   None.
#

# TAG: req_hdr_add
#
# Append a user-defined header to HTTP request message before forwarding
# it to backend server.
#
# Syntax:
#   req_hdr_add <name> <value>;
#
# Example:
#   req_hdr_add X-Forwarded-Host "mydomain.com"
#
# Default:
#   None.
#

# TAG: req_hdr_set
#
# Replace or remove a user-defined header from HTTP request message before
# forwarding it to backend server.
#
# Syntax:
#   req_hdr_set <name> <value>;
#   req_hdr_set <name>;
#
# Example:
#   req_hdr_set Host "mydomain.com"
#   req_hdr_set Cookie
#
# Default:
#   None.
#

# TAG: vhost
#
# Group of directives applied to virtual host with specified name.
#
# Syntax:
#   vhost NAME {
#       <directive>;
#       ...
#       <directive>;
#   }
#
# NAME is a unique identifier of virtual host that may be used to refer it
# from HTTP tables (see 'http_chain' directive).
#
# <directive> is one of 'location', 'proxy_pass', 'cache_bypass', 'cache_fulfill',
# 'nonidempotent', 'hdr_add' or 'http_post_validate' directives (see the
# corresponding directives' description).
#
# Example:
#   vhost app {
#       proxy_pass 3rdparty;
#       location prefix "?" {
#           proxy_pass heavy backup=bkp_grp;
#           nonidempotent GET prefix "/users/";
#       }
#       location prefix "/static/" {
#           proxy_pass base;
#           cache_fulfill suffix ".jpg" ".png";
#       }
#   }
#
# Default:
#   There is a special vhost called "default". All 'vhost' internal directives
#   (specified above) defined outside of any vhost, are added to the
#   "default" vhost.
#

# TAG: location
#
# Group of directives applied to specific location defined by a string
# and a match operator. Matching is done against URL in a request.
#
# Syntax:
#   location <OP> <string> {
#       <directive>;
#       ...
#       <directive>;
#   }
#
# <OP> is a match operator, one of 'eq', 'prefix', 'suffix', or '*'.
# <string> is a verbatim string matched against URL in a request.
# <directive> is one of 'proxy_pass', 'cache_bypass', 'cache_fulfill',
# 'nonidempotent', 'hdr_add', 'http_post_validate' or Frang limit directives.
#
# Default:
#   None.
#

# TAG: proxy_pass
#
# Directive which is used in 'vhost' and 'location' blocks and specifies
# server groups to which requests for current vhost and/or location must
# be sent.
#
# Syntax:
#   proxy_pass GROUP [backup=BKP_GROUP];
#
# GROUP is the reference to a previously defined 'srv_group'.
#
# Optional parameter BKP_GROUP is the reference to a previously defined backup
# 'srv_group'. Requests will be sent to backup BKP_GROUP, if none of the
# servers in specified GROUP are available.
#
# Directive 'proxy_pass' is mandatory for 'vhost' and 'location' directives
# blocks. For explicit "default" vhost (and included locations) only
# 'proxy_pass' with "default" server groups is allowed. It's created
# automatically if it's missed. For implicit "default" vhost 'proxy_pass'
# directive is not allowed since "default" vhost can point only to "default"
# server group.
#
# Example:
#   vhost app {
#       proxy_pass app backup=bkp_app;
#
#       location prefix "/beta/" {
#           proxy_pass beta;
#           ...
#       }
#   }
#

# TAG: filter_db
#
# Path to a filter database file used as a storage for Tempesta FW filter rules.
# The same as cache_db.
#
# Default:
#   filter_db /opt/tempesta/db/filter.tdb;
#

# TAG: drop_tbl_size
#
# Size of filter drop table.
#
# Syntax:
#   filter_tbl_size SIZE
#
# Default:
#   filter_tbl_size 16777216;  # 16MB
#

# TAG: sticky
#
# Group of directives applied to the Tempesta sticky cookie and sticky sessions.
# Defined inside vhost definitions.
# Syntax:
#   vhost NAME {
#     sticky {
#         <directive>;
#         ...
#         <directive>;
#     }
#   }
#
# <directive> is one of 'cookie', 'secret', 'sess_lifetime', sticky_sessions',
# 'js_challenge' or 'learn' directives (see the corresponding directives'
# description). The configuration group can be listed at top level outside
# any 'vhost' directives to modify current defauls.
#
# Default: disabled.

# TAG: cookie
#
# Syntax:
#   cookie [name=<COOKIE_NAME>] [enforce] [max_misses=<LIMIT>] [timeout=<TMT>]
#          [options=<OPTIONS>]
#
# Default:
#   Tempesta sticky cookie is not used.
#
# COOKIE_NAME is the name of Tempesta sticky cookie is used in HTTP
# requests that pass through Tempesta. When not specified explicitly,
# a default name is used.
#
# 'enforce' - enforce the use of Tempesta sticky cookie in all HTTP
# requests that come to Tempesta. If Tempesta sticky cookie is not
# found in an HTTP request, a client get an HTTP 302 response that
# redirects the client to the same URI, and prompts that Tempesta
# sticky cookie is set in the request.
#
# 'max_misses' - sets the maximum count of redirected requests (with no
# cookie or with incorrect cookie value). This option is applicable
# only if 'enforce' mode is enabled. If configured limit is exhausted,
# the corresponding client will be blocked. LIMIT is non-negative
# integer (default value is 0, which means that limit verification
# is disabled).
#
# 'timeout' - sets the maximum period between the first redirected
# request and successful cookie verification from certain client.
# This option is applicable only if 'enforce' mode is enabled and
# 'max_misses' parameter has value greater then zero. If configured
# timeout is expired, the corresponding client will be blocked.
# TMT is non-negative integer (default value is 0, which means that
# timeout tracking is disabled).
#
# 'options' - string of extra options for the Tempesta sticky cookie. Added
# after cookie value as a plain string in 'Set-Cookie' header. The field may
# contain multiple options, in this case, the options must be split with
# semi-colon. E.g.: 'options="Domain=<domain-value>; Secure; HttpOnly",
# 'options="Max-Age=3600"'.
#
# NOTE: line breaks inside the directive are not allowed. See 'js_challenge'.
#
# Examples:
#   cookie;                         # Enable sticky cookie with default name.
#   cookie enforce;                 # Enforce sticky cookie with default name.
#   cookie name=__cookie__ enforce; # Enable sticky cookie with custom name.
#

# TAG: learn
#
# Syntax:
#   learn name=<COOKIE_NAME>;
#
# Learn HTTP sessions created by a backend server. When the backend server
# creates a session it sends 'Set-Cookie' header to the client. If the option
# is enabled, a new HTTP session entry is created at receiving 'Set-Cookie'
# header and pinned to the origin backend server. All requests with the same
# cookie will be forwarded to the same backend server.
#
# The session in Tempesta expires after 'sess_lifetime' seconds after the last
# received request. Directive `sticky_sessions` is automatically enabled with
# directive 'learn'.
#
# Examples:
#   learn name=user-id
#

# TAG: secret
#
# Secret string for sticky cookie.
#
# Syntax:
#   secret <string>
#
# This is secret (key) used for HMAC calculation for Sticky cookie value.
# It's desirable to keep this value in secret to prevent automatic cookies
# generation on attacker side. By default Tempesta generates a new random
# value for the secret on start. This means that all user HTTP sessions are
# invalidated on Tempesta restart. Maximum length of the key is 20 bytes.
#
# Example:
#   secret "f00)9eR59*_/22";
#
# Default:
#   Random bytes.
#

# TAG: sess_lifetime
#
# HTTP session life time in seconds. Zero value means unlimited life time.
# This option doesn't affect sticky cookie expire time - it's a session,
# temporal, cookie.
#
# Syntax:
#   sess_lifetime NUM;
#
# Example:
#   sess_lifetime 900;
#
# Default:
#   sess_lifetime 0;
#

# TAG: sticky_sessions
#
# Load balancing method. Forward all requests from client to the same
# upstream server. Applied to a server group.
#
# Syntax:
#   sticky_sessions [allow_failover]
#
# First request to a server group in client's HTTP session will be forwarded
# to upstream server chosen by scheduler applied to the server group. All the
# following requests to that group in this session will pass through scheduler
# and will be forwarded to the same server. Client will receive 502 error
# if pinned upstream server went offline. Method can't be applied if client
# does not support cookies or Tempesta sticky cookie is disabled.
#
# Note: Session preservation is the priority for the method, so client will
# be served by backup server group even when primary group is back online.
#
# 'allow_failover' - Pin session to a new upstream server and print the warning
# if the last pinned server went offline instead of sending 502 error to client.
#
# Examples:
#   srv_group app {
#       server 10.10.0.1:8080;
#       server 10.10.0.2:8080;
#       server [fc00::3]:8081 conns_n=1;
#
#       sticky_sessions;
#   }
#
# Default:
#   Sticky sessions are disabled.
#

# TAG: js_challenge
#
# Enhance DDoS protection if bots supports HTTP cookies and can follow
# redirects. Requires 'sticky' cookies to be enabled.
#
# Syntax:
#   js_challenge delay_min=<TIME> delay_range=<TIME> [resp_code=<CODE>]
#                [delay_limit=<TIME>] [SCRIPT_TEMPLATE]
#
# 'delay_min'   - Minimal timeout to make a client wait.
# 'delay_range' - Allowed time period to receive and accept client's session.
# 'delay_limit' - Maximum time to deliver request from client to the Tempesta
#                 server. Optional parameter. Default is 1/10 of
#                 'delay_range'.
# 'resp_code'   - Status code for response with JS challenge. Optional
#                 parameter, default is "503".
# <SCRIPT_TEMPLATE> - path to JS challenge script.. Optional parameter, default
#                 is "/etc/tempesta/js_challenge.conf".
# <TIME>        - time in usecs.
#
# NOTE: During start process 'tempesta.sh' uses 'grep' to update
# <SCRIPT_TEMPLATE> file with values described in 'js_challenge' directive, so
# line breaks are not allowed inside the directive.
#
# Example:
#   js_challenge resp_code=503 delay_min=1000 delay_range=3000 delay_limit=300
#                /etc/ddos_redirect.html
#

# TAG: http_post_validate
#
# Validate POST requests.
# Parses Content-Type header field, and rewrites it for multipart/form-data type
# of payload, to prevent evasion attacks. All parameters other than "boundary"
# are removed.
#
# Syntax:
#   http_post_validate
#
# Default:
#   Validation is disabled.
#

#
# Frang configuration.
#

# TAG: frang_limits
#
# The section containing static limits for the classifier. Can appear at top
# level, inside 'vhost' directive, inside 'location' directive. Once the
# directive is listed in the configuration it redefines default values for the
# following and nested sections of 'vhost' and 'location' directives.
#
# Syntax:
#   frang_limits {
#       ip_block off|on;
#       request_rate NUM;
#       request_burst NUM;
#       connection_rate NUM;
#       connection_burst NUM;
#       concurrent_connections NUM;
#       client_header_timeout NUM;
#       client_body_timeout NUM;
#       http_uri_len NUM;
#       http_field_len NUM;
#       http_body_len NUM;
#       http_header_cnt NUM;
#       http_header_chunk_cnt NUM;
#       http_body_chunk_cnt NUM;
#       http_strict_host_checking true|false;
#       http_methods [METHOD]...;
#       http_ct_required true|false;
#       http_method_override_allowed true|false;
#       http_ct_vals ["CONTENT_TYPE"]...;
#       http_resp_code_block RESPONSE_CODE [RESPONSE_CODE]...
#                            LIMIT TIME_FRAME_IN_SECONDS;
#  }
#
#  Options with names '*_rate' define requests/connections rate per second.
#  '*_burst' are temporal burst for 1/FRANG_FREQ of second.
#  'http_*' are static limits for contents of an HTTP request.
#
# Example:
#    frang_limits {
#        request_rate 20;
#        request_burst 15;
#        connection_rate 8;
#        connection_burst 6;
#        concurrent_connections 8;
#        client_header_timeout 20;
#        client_body_timeout 10;
#        http_uri_len 1024;
#        http_field_len 256;
#        http_ct_required false;
#        http_methods get post head;
#        http_ct_vals "text/plain" "text/html";
#        http_header_chunk_cnt 10;
#        http_body_chunk_cnt 0;
#        http_resp_code_block 403 404 502 20 5;
#   }
#
# Default:
#   All limits are disabled (the values are set to zero/false/empty).
#

# TAG: whitelist_mark
#
# Marks to designate requests from particular sources as whitelisted
# in TempestaFW.
#
# Syntax:
#   whitelist_mark MARKS
#
# MARKS is a list of space separated marks (integers in range from
# 0 to UINT_MAX), which can be set for particular types of network
# packets via nftables/iptables interfaces to designate such packets
# as allowable to bypass Frang filtering and Sticky cookies procedures
# of TempestaFW.
#
# Example:
#   whitelist_mark 1 7531 777 11235;
#

# TAG: http_uri_brange
# TAG: http_token_brange
# TAG: http_qetoken_brange
# TAG: http_nctl_brange
# TAG: http_xff_brange
# TAG: http_cookie_brange
# TAG: http_etag_brange
#
# Defines allowed characters sets for:
#   - 'uri'
#       URI path. Note that Accept and Referer headers are also verified by
#       the characters set.
#   - 'token'
#       Each header field value defined with 'token' by RFC 7230,
#       e.g. unknown for Tempesta FW HTTP methods and HTTP headers,
#       Connection or Transfer-Encoding extension values, Cookie
#       name (note that value is processed with it's own alphabet),
#       E-Tag value;
#   - 'qetoken'
#       'token' with DQUOTE and '=', e.g. "Cache-Control", "Pragma", and
#       "Keep-Alive" headers extension values.
#   - 'nctl'
#       Generic filed values defined by RFC 7230 Appendix B and
#       RFC 5234 Appendix B.1. Currently used for HTTP date headers,
#       such as Expires, Date, Last-Modified, and If-Modified-Since,
#       extension values only.
#   - 'xff'
#       X-Forwarded-For Node ID defined by RFC 7239.
#   - 'cookie'
#       Cookie header values.
#   - 'etag'
#       Etag header values.
#
# Syntax:
#   http_XXX_brange RANGES
#
# RANGES is a list of space separated ranges (integers in range [0-255]) or
# integers for single characters. Hex and decimal encodings are accepted.
#
# Example:
#   http_uri_brange 0x2f 0x61-0x7a 48 0x2A;
#

#
# Health monitoring configuration.
#

# TAG: health_check
#
# Section for health monitor configuration.
#
# Syntax:
#   health_check NAME {
#       request      REQ_STRING;
#       request_url  URL_STRING;
#       resp_code    RESPONSE_CODES;
#       resp_crc32   CRC32;
#       timeout      TIMEOUT;
#   }
#
# NAME is a unique identifier of health monitor.
#
# REQ_STRING is a string with health monitoring request.
#
# Default:
#   request "GET / HTTTP/1.0\r\n\r\n";
#
# URL_STRING is a string with url; client requests with this url will be
# used as health monitoring requests.
#
# Default:
#   request_url "/";
#
# RESPONSE_CODES is a list of space separated HTTP statuses which will signal
# that server is alive.
#
# CRC32 is a hex number - calculated CRC32 checksum for expected response body.
#
# TIMEOUT is a timeout in seconds after which new health monitoring request
# (specified in 'request' directive) will be sent to backend server (if there
# were no client requests satisfying condition, given in 'request_url'
# directive).
#
# This section may be repeated to configure several health monitors in
# TempestaFW. Default health monitor with name "auto" is always present in
# TempestaFW. Its configuration is given below:
#
# Example:
#   health_check auto {
#       request      "GET / HTTTP/1.0\r\n\r\n";
#       request_url  "/";
#       resp_code    200;
#       timeout      10;
#   }
#
# Default:
#   Health monitor is disabled.
#

# TAG: server_failover_http
#
# Directive for monitoring of response HTTP statuses.
#
# Syntax:
#   server_failover_http RESPONSE_CODE COUNT TIMEOUT;
#
# RESPONSE_CODE is a HTTP status code.
#
# COUNT is a number of responses.
#
# TIMEOUT is a timeframe in seconds.
#
# This directive means that when TempestaFW receives from some
# server (which is in srv_group with enabled health monitor) COUNT
# of responses with RESPONSE_CODE status in TIMEOUT seconds, then
# such server is considered not alive in HTTP sense, and new client
# requests will not scheduled on this server until it becomes alive
# again (see 'health_check' directive). This directive may be repeated
# to configure monitoring of several HTTP statuses.
#
# Example:
#    server_failover_http 404 300 10;
#
# Default:
#   Health monitor is disabled.
#

# TAG: health
#
# Directive for health monitor specifying. Health monitor is specified
# for separate server groups (explicit or implicit), and for such groups
# a monitor with specific ID is enabled. This means, that for servers
# from such groups - all directives 'server_failover_http' and section
# 'health_check' (with corresponding ID) are applied.
#
# Syntax:
#   health ID;
#
# ID is a health monitor identifier (see 'health_check' directive).
#
# Examples:
#   srv_group app {
#       server 10.10.0.1:8080;
#       server 10.10.0.2:8080;
#
#       health auto;
#   }
#
# Default:
#   Health monitor is disabled.
#

# TAG: client_db
#
# Path to a client database file used as a storage for clients info.
# The same as cache_db.
#
# Default:
#   client_db /opt/tempesta/db/client.tdb;
#

# TAG: client_tbl_size
#
# Size of client drop table.
#
# Syntax:
#   client_tbl_size SIZE
#
# Default:
#   client_tbl_size 16777216;  # 16MB
#

# TAG: sessions_db
#
# Path to a HTTP sessions database file used as a storage for HTTP sessions info.
# The same as cache_db.
#
# Default:
#   sessions_db /opt/tempesta/db/sessions.tdb;
#

# TAG: sessions_tbl_size
#
# Size of HTTP sessions table.
#
# Syntax:
#   sessions_tbl_size SIZE
#
# Default:
#   sessions_tbl_size 16777216;  # 16MB
#
